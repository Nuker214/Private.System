# fly.toml app configuration file
# See https://fly.io/docs/reference/configuration/ for more details.

app = "your-integrated-discord-app" # <<< CHANGE THIS to a unique name for your Fly.io app
primary_region = "iad"             # <<< CHANGE THIS to your preferred region (e.g., 'fra' for Frankfurt, 'syd' for Sydney, 'lhr' for London)

[build]
  dockerfile = "Dockerfile"

[env]
  # IMPORTANT: These environment variables should primarily be set as Fly.io SECRETS!
  # This section only shows defaults or is used for clarity during local testing.
  # Your actual secrets (DISCORD_TOKEN, Channel IDs, etc.) are set via `flyctl secrets set KEY=VALUE`
  # The 'PORT' environment variable is provided by Fly.io at runtime.
  PORT = "8080" # This specifies the default port your app will bind to internally.
  WEBSITE_API_BASE_URL = "http://localhost:8080" # Bot uses this to call Flask within the same container

# This configures Fly.io to route public HTTP(S) traffic to your internal Flask app.
# It ensures your website (served by Flask) is publicly accessible with HTTPS.
[[services]]
  internal_port = 8080 # This must match the port your Flask app listens on (WEB_SERVER_PORT in main.py)
  protocol = "tcp"
  processes = ["app"]  # This assumes your Dockerfile starts a single 'app' process.

  [[services.ports]]
    port = 80
    handlers = ["http"]
    force_https = true # Redirects HTTP traffic to HTTPS automatically

  [[services.ports]]
    port = 443
    handlers = ["tls", "http"]

  [services.concurrency]
    type = "connections"
    hard_limit = 100 # Adjust based on your expected traffic
    soft_limit = 80  # Adjust based on your expected traffic

# Fly.io has a small default VM configuration. For always-on bot use:
# The free tier often gives enough resources for one basic instance.
# Ensure your plan allows for persistent uptime of your "app" type.
[processes]
  app = "python main.py" # Explicitly define the process type and command
